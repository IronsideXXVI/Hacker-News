name: Build, Notarize & Release

on:
  push:
    tags:
      - 'v*'

env:
  APP_NAME: "Hacker News"
  SCHEME: "Hacker News"
  PROJECT: "Hacker News.xcodeproj"
  BUNDLE_ID: "com.IronsideXXVI.Hacker-News"
  TEAM_ID: "69Y3X8R7D7"
  SIGNING_IDENTITY: "Developer ID Application"

permissions:
  contents: write

jobs:
  build-and-release:
    runs-on: macos-26
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select Xcode
        run: sudo xcode-select -s /Applications/Xcode_26.2.app/Contents/Developer

      # ── Import Developer ID certificate ──────────────────────────────
      - name: Import signing certificate
        env:
          P12_BASE64: ${{ secrets.DEVELOPER_ID_CERTIFICATE_P12 }}
          P12_PASSWORD: ${{ secrets.DEVELOPER_ID_CERTIFICATE_PASSWORD }}
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/build.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          echo "$P12_BASE64" | base64 --decode > $RUNNER_TEMP/cert.p12
          security import $RUNNER_TEMP/cert.p12 \
            -k "$KEYCHAIN_PATH" \
            -P "$P12_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security
          rm $RUNNER_TEMP/cert.p12

          # Allow codesign to use the keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Add to search list
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | tr -d '"')

      # ── Set up notarization credentials ──────────────────────────────
      - name: Set up App Store Connect API key
        env:
          API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          API_KEY_CONTENT: ${{ secrets.APPLE_API_KEY_CONTENT }}
        run: |
          mkdir -p ~/private_keys
          echo "$API_KEY_CONTENT" > ~/private_keys/AuthKey_${API_KEY_ID}.p8

      # ── Resolve packages ─────────────────────────────────────────────
      - name: Resolve Swift packages
        run: |
          xcodebuild -resolvePackageDependencies \
            -project "$PROJECT" \
            -scheme "$SCHEME" \
            -clonedSourcePackagesDirPath "$RUNNER_TEMP/packages"

      # ═══════════════════════════════════════════════════════════════
      #  PHASE 1: Build & Sign the .app
      # ═══════════════════════════════════════════════════════════════

      # ── Step 1: Archive ──────────────────────────────────────────────
      - name: "Step 1: Archive"
        run: |
          xcodebuild archive \
            -project "$PROJECT" \
            -scheme "$SCHEME" \
            -configuration Release \
            -archivePath $RUNNER_TEMP/app.xcarchive \
            -clonedSourcePackagesDirPath "$RUNNER_TEMP/packages" \
            -destination "generic/platform=macOS" \
            CODE_SIGN_IDENTITY="-" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO \
            -quiet

      # ── Step 2: Extract and re-sign with Developer ID ────────────────
      - name: "Step 2: Extract app and sign with Developer ID"
        run: |
          APP_PATH="$RUNNER_TEMP/$APP_NAME.app"

          # Copy the .app out of the archive
          cp -R "$RUNNER_TEMP/app.xcarchive/Products/Applications/$APP_NAME.app" "$APP_PATH"

          # Remove the development provisioning profile
          rm -f "$APP_PATH/Contents/embedded.provisionprofile"

          # Strip quarantine/extended attributes
          xattr -cr "$APP_PATH"

          # Create entitlements for Developer ID distribution
          cat > $RUNNER_TEMP/dist-entitlements.plist << ENTEOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
            "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.app-sandbox</key>
              <true/>
              <key>com.apple.security.network.client</key>
              <true/>
              <key>com.apple.security.temporary-exception.mach-lookup.global-name</key>
              <array>
                  <string>${BUNDLE_ID}-spks</string>
                  <string>${BUNDLE_ID}-spki</string>
              </array>
          </dict>
          </plist>
          ENTEOF

          # Sign the Sparkle framework and all its nested components (no sandbox)
          SPARKLE_FRAMEWORK="$APP_PATH/Contents/Frameworks/Sparkle.framework"
          codesign --force --deep \
            --sign "$SIGNING_IDENTITY" \
            --timestamp \
            --options runtime \
            "$SPARKLE_FRAMEWORK"

          # Sign the main app only (with sandbox entitlements, no --deep)
          codesign --force \
            --sign "$SIGNING_IDENTITY" \
            --timestamp \
            --options runtime \
            --entitlements $RUNNER_TEMP/dist-entitlements.plist \
            "$APP_PATH"

      # ── Step 3: Verify app code signing ──────────────────────────────
      - name: "Step 3: Verify app code signature"
        run: |
          codesign -v --verbose "$RUNNER_TEMP/$APP_NAME.app" 2>&1

      # ═══════════════════════════════════════════════════════════════
      #  PHASE 2: Notarize & Staple the .app
      # ═══════════════════════════════════════════════════════════════

      # ── Step 4: Notarize the .app ────────────────────────────────────
      - name: "Step 4: Notarize app"
        env:
          API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          API_ISSUER_ID: ${{ secrets.APPLE_API_ISSUER_ID }}
        run: |
          APP_PATH="$RUNNER_TEMP/$APP_NAME.app"

          # Create a zip for notarization submission
          ditto -c -k --keepParent "$APP_PATH" $RUNNER_TEMP/app-for-notarization.zip

          RESULT=$(xcrun notarytool submit $RUNNER_TEMP/app-for-notarization.zip \
            --key ~/private_keys/AuthKey_${API_KEY_ID}.p8 \
            --key-id "$API_KEY_ID" \
            --issuer "$API_ISSUER_ID" \
            --wait 2>&1)
          echo "$RESULT"

          if echo "$RESULT" | grep -q "status: Invalid"; then
            SUBMISSION_ID=$(echo "$RESULT" | grep "id:" | head -1 | awk '{print $2}')
            echo "::error::Notarization failed. Fetching log..."
            xcrun notarytool log "$SUBMISSION_ID" \
              --key ~/private_keys/AuthKey_${API_KEY_ID}.p8 \
              --key-id "$API_KEY_ID" \
              --issuer "$API_ISSUER_ID" 2>&1
            exit 1
          fi

          rm -f $RUNNER_TEMP/app-for-notarization.zip

      # ── Step 5: Staple the .app ──────────────────────────────────────
      - name: "Step 5: Staple app"
        run: |
          for i in 1 2 3 4 5; do
            if xcrun stapler staple "$RUNNER_TEMP/$APP_NAME.app"; then
              exit 0
            fi
            echo "Staple attempt $i failed, waiting 15s for ticket propagation..."
            sleep 15
          done
          echo "::error::Stapling failed after 5 attempts"
          exit 1

      # ── Step 6: Verify notarized app ─────────────────────────────────
      - name: "Step 6: Verify notarized app"
        run: |
          xcrun stapler validate "$RUNNER_TEMP/$APP_NAME.app"
          spctl -a -v "$RUNNER_TEMP/$APP_NAME.app" 2>&1 || true

      # ═══════════════════════════════════════════════════════════════
      #  PHASE 3: Create, Sign, Notarize & Staple the DMG
      # ═══════════════════════════════════════════════════════════════

      # ── Step 7: Create DMG ───────────────────────────────────────────
      - name: "Step 7: Create DMG"
        run: |
          APP_PATH="$RUNNER_TEMP/$APP_NAME.app"
          DMG_TMP="$RUNNER_TEMP/tmp.dmg"
          VOL_NAME="$APP_NAME"
          VOL_PATH="/Volumes/$VOL_NAME"

          # Calculate DMG size (app size + 20MB headroom)
          APP_SIZE_KB=$(du -sk "$APP_PATH" | cut -f1)
          DMG_SIZE_MB=$(( (APP_SIZE_KB / 1024) + 20 ))

          # Detach any previously mounted volume with the same name
          if [ -d "$VOL_PATH" ]; then
            hdiutil detach "$VOL_PATH" -force 2>/dev/null || true
          fi

          # Create a temporary read-write DMG
          hdiutil create \
            -size "${DMG_SIZE_MB}m" \
            -fs HFS+ \
            -volname "$VOL_NAME" \
            "$DMG_TMP"

          # Mount it
          MOUNT_OUTPUT=$(hdiutil attach "$DMG_TMP" -readwrite -noverify)
          DEVICE=$(echo "$MOUNT_OUTPUT" | grep "/dev/" | head -1 | awk '{print $1}')

          if [ ! -d "$VOL_PATH" ]; then
            echo "::error::Failed to mount DMG at $VOL_PATH"
            exit 1
          fi

          # Copy app to mounted volume using tar (bypasses xattr/provenance permission issues)
          (cd "$(dirname "$APP_PATH")" && tar cf - "$APP_NAME.app") | (cd "$VOL_PATH" && tar xf -)

          # Verify the app was actually copied
          if [ ! -d "$VOL_PATH/$APP_NAME.app/Contents/MacOS" ]; then
            echo "::error::Failed to copy app to DMG"
            exit 1
          fi

          # Create symlink to /Applications
          ln -s /Applications "$VOL_PATH/Applications"

          # Add background image
          BACKGROUND="resources/dmg-background.png"
          if [ -f "$BACKGROUND" ]; then
            mkdir -p "$VOL_PATH/.background"
            cp "$BACKGROUND" "$VOL_PATH/.background/background.png"
          fi

          # Use AppleScript to configure the Finder window appearance
          osascript <<APPLESCRIPT
          tell application "Finder"
            tell disk "$VOL_NAME"
              open
              set current view of container window to icon view
              set toolbar visible of container window to false
              set statusbar visible of container window to false
              -- Compact window: 480px wide, 300px tall
              set bounds of container window to {400, 200, 880, 500}

              set viewOptions to the icon view options of container window
              set arrangement of viewOptions to not arranged
              set icon size of viewOptions to 100
              set text size of viewOptions to 13
              set background picture of viewOptions to file ".background:background.png"

              set position of item "$APP_NAME.app" of container window to {120, 150}
              set position of item "Applications" of container window to {360, 150}

              close
              open

              -- Give Finder time to render icons and apply settings
              delay 3
              close
            end tell
          end tell
          APPLESCRIPT

          # Ensure .DS_Store is written to disk
          sync

          # Detach the volume
          hdiutil detach "$DEVICE"

          # Convert to read-only compressed DMG
          hdiutil convert "$DMG_TMP" \
            -format UDZO \
            -imagekey zlib-level=9 \
            -o "$RUNNER_TEMP/$APP_NAME.dmg"

          rm -f "$DMG_TMP"

          echo "DMG_PATH=$RUNNER_TEMP/$APP_NAME.dmg" >> $GITHUB_ENV

      # ── Step 8: Sign DMG ─────────────────────────────────────────────
      - name: "Step 8: Sign DMG"
        run: |
          codesign \
            --sign "$SIGNING_IDENTITY" \
            --timestamp \
            "$DMG_PATH"

      # ── Step 9: Notarize DMG ─────────────────────────────────────────
      - name: "Step 9: Notarize DMG"
        env:
          API_KEY_ID: ${{ secrets.APPLE_API_KEY_ID }}
          API_ISSUER_ID: ${{ secrets.APPLE_API_ISSUER_ID }}
        run: |
          xcrun notarytool submit "$DMG_PATH" \
            --key ~/private_keys/AuthKey_${API_KEY_ID}.p8 \
            --key-id "$API_KEY_ID" \
            --issuer "$API_ISSUER_ID" \
            --wait

      # ── Step 10: Staple DMG ──────────────────────────────────────────
      - name: "Step 10: Staple DMG"
        run: |
          for i in 1 2 3 4 5; do
            if xcrun stapler staple "$DMG_PATH"; then
              exit 0
            fi
            echo "Staple attempt $i failed, waiting 15s for ticket propagation..."
            sleep 15
          done
          echo "::error::Stapling failed after 5 attempts"
          exit 1

      # ── Step 11: Final verification ──────────────────────────────────
      - name: "Step 11: Verify notarized DMG"
        run: |
          xcrun stapler validate "$DMG_PATH"
          spctl -a -v -t install "$DMG_PATH" 2>&1

      # ═══════════════════════════════════════════════════════════════
      #  PHASE 4: Release
      # ═══════════════════════════════════════════════════════════════

      # ── Sparkle signature ────────────────────────────────────────────
      - name: Generate Sparkle EdDSA signature
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_PRIVATE_KEY }}
        run: |
          # Find sign_update in the resolved Sparkle package
          SIGN_UPDATE=$(find "$RUNNER_TEMP/packages" -name "sign_update" -type f | head -1)

          if [ -z "$SIGN_UPDATE" ]; then
            echo "::error::Could not find sign_update tool in Sparkle package"
            exit 1
          fi

          chmod +x "$SIGN_UPDATE"

          # Generate signature
          SIGNATURE=$("$SIGN_UPDATE" "$DMG_PATH" --ed-key-file <(echo "$SPARKLE_PRIVATE_KEY"))
          echo "SPARKLE_SIGNATURE<<EOF" >> $GITHUB_ENV
          echo "$SIGNATURE" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          # Extract individual attributes for appcast
          ED_SIGNATURE=$(echo "$SIGNATURE" | grep -o 'sparkle:edSignature="[^"]*"' | cut -d'"' -f2)
          LENGTH=$(echo "$SIGNATURE" | grep -o 'length="[^"]*"' | cut -d'"' -f2)
          echo "ED_SIGNATURE=$ED_SIGNATURE" >> $GITHUB_ENV
          echo "DMG_LENGTH=$LENGTH" >> $GITHUB_ENV

      # ── Extract version info ─────────────────────────────────────────
      - name: Extract version info
        run: |
          APP_PATH="$RUNNER_TEMP/$APP_NAME.app"
          VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$APP_PATH/Contents/Info.plist")
          BUILD=$(/usr/libexec/PlistBuddy -c "Print :CFBundleVersion" "$APP_PATH/Contents/Info.plist")
          TAG="${GITHUB_REF#refs/tags/}"

          echo "APP_VERSION=$VERSION" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD" >> $GITHUB_ENV
          echo "TAG=$TAG" >> $GITHUB_ENV

      # ── Build appcast entry ──────────────────────────────────────────
      - name: Build appcast.xml
        run: |
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/$TAG/HackerNews-${APP_VERSION}.dmg"
          PUB_DATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")

          cat > $RUNNER_TEMP/appcast.xml << APPCAST_EOF
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle" xmlns:dc="http://purl.org/dc/elements/1.1/">
            <channel>
              <title>$APP_NAME</title>
              <link>https://ironsidexxvi.github.io/Hacker-News/appcast.xml</link>
              <description>Most recent updates for $APP_NAME</description>
              <language>en</language>
              <item>
                <title>Version $APP_VERSION</title>
                <pubDate>$PUB_DATE</pubDate>
                <sparkle:version>$BUILD_NUMBER</sparkle:version>
                <sparkle:shortVersionString>$APP_VERSION</sparkle:shortVersionString>
                <sparkle:minimumSystemVersion>15.0</sparkle:minimumSystemVersion>
                <enclosure
                  url="$DOWNLOAD_URL"
                  length="$DMG_LENGTH"
                  type="application/octet-stream"
                  sparkle:edSignature="$ED_SIGNATURE"
                />
              </item>
            </channel>
          </rss>
          APPCAST_EOF

      # ── Create GitHub Release ────────────────────────────────────────
      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cp "$DMG_PATH" "$RUNNER_TEMP/HackerNews-${APP_VERSION}.dmg"

          gh release create "$TAG" \
            "$RUNNER_TEMP/HackerNews-${APP_VERSION}.dmg#Hacker News ${APP_VERSION}" \
            --title "$APP_NAME $APP_VERSION" \
            --generate-notes

      # ── Deploy appcast to GitHub Pages ───────────────────────────────
      - name: Deploy appcast to gh-pages
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Fetch gh-pages
          git fetch origin gh-pages || true

          # Set up worktree for gh-pages
          PAGES_DIR=$RUNNER_TEMP/gh-pages
          git worktree add "$PAGES_DIR" gh-pages 2>/dev/null || {
            git worktree add --detach "$PAGES_DIR"
            cd "$PAGES_DIR"
            git checkout --orphan gh-pages
            git reset --hard
            cd -
          }

          # Copy appcast
          cp $RUNNER_TEMP/appcast.xml "$PAGES_DIR/appcast.xml"

          # Commit and push
          cd "$PAGES_DIR"
          git add appcast.xml
          git diff --cached --quiet && echo "No changes to appcast" && exit 0
          git commit -m "Update appcast for $TAG"
          git push origin gh-pages

      # ── Cleanup ──────────────────────────────────────────────────────
      - name: Cleanup keychain
        if: always()
        run: |
          security delete-keychain $RUNNER_TEMP/build.keychain-db 2>/dev/null || true
          rm -f ~/private_keys/AuthKey_*.p8
